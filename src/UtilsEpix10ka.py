# -*- coding: utf-8 -*-
"""
Created on Fri May 11 18:25:48 2018 
CALIBRATION - TEST PULSES

@author: blaj
"""
#--------------------
import os
import sys
import logging
logger = logging.getLogger(__name__)

from time import sleep
from psana import DataSource, Detector
import numpy as np

from PSCalib.DCUtils import env_time, str_tstamp
from Detector.UtilsEpix import id_epix, CALIB_REPO_EPIX10KA, alias_for_id, create_directory
from Detector.PyDataAccess import get_epix10ka_config_object
#from Detector.GlobalUtils import print_ndarr, divide_protected

import matplotlib.pyplot as plt
#from numba import jit

# supress matplotlib deprication warnings
import warnings
warnings.filterwarnings("ignore",".*GUI is implemented.*")

#--------------------

GAIN_MODES    = ['FH','FM','FL','AHL-H','AML-M','AHL-L','AML-L']
GAIN_MODES_IN = ['FH','FM','FL','AHL-H','AML-M']

#--------------------

def init_plot(x,xx,itrim):
    f0=plt.figure(0,facecolor='w');f0.clf()
    ax0=f0.add_subplot(111)
    col='r' if itrim else 'g' # 'g'-medium 'r'-high gain
    line0,=ax0.plot(x,x,'ko',markersize=1)
    line1,=ax0.plot(xx,xx,'-',color=col,linewidth=1)
    line2,=ax0.plot(xx,xx,'b-',linewidth=1)
    ax0.set_xlim(0,1024);ax0.set_ylim(0,16384)
    ax0.set_xticks(np.arange(0,1025,128))
    ax0.set_yticks(np.arange(0,16385,2048))
    handle=f0,ax0,line0,line1,line2
    return handle

#--------------------

def update_plot(handle,trace,xx,pf0,pf1):
    f0,ax0,line0,line1,line2=handle
    line0.set_ydata(trace%16384)
    line1.set_ydata(np.polyval(pf0,xx))
    line2.set_ydata(np.polyval(pf1,xx))
    plt.pause(0.1)    

#--------------------

#@jit
def fit(block, itrim, ny=352, nx=384, display=True):
    mf,my,mx=block.shape
    fits=np.zeros((my,mx,2,2))
    nsp=np.zeros((my,mx),dtype=np.int16)
    
    x=np.arange(3*1024)%1024
    xx=np.linspace(1024,0,100)
    
    if display:
        handle=init_plot(x,xx,itrim)
    
    for iy in range(my):
        for ix in range(mx):
            trace=block[:,iy,ix]
            ixoff=np.argmin(np.diff(trace[:1025],axis=0),axis=0)+1 #find pulser value 0
            trace=trace[ixoff:ixoff+3*1024]                        #select the first 3 complete pulser cycles (0 to 1023)
            try:
                isp=int(np.median(np.where(np.diff(trace)>1000)[0]%1024))  #estimate median position of switching point
                nsp[iy,ix]=isp
            except ValueError:
                testval=np.median(trace%16384)
                ixoff=1024 if testval<0.5 else 0
            
            idx0=x<isp-50; idx1=x>isp+50                           #select data to the left and right of switching point
            if idx0.sum()>10:
                pf0=np.polyfit(x[idx0],trace[idx0]%16384,1)        #fit high/medium gain trace
            else:
                pf0=np.array([0,0])                                #or set to 0 if not enough data points
            if idx1.sum()>10:
                #pf1=np.polyfit(x[idx1],trace[idx1]%16384,1)       #this doesn't work!
                gl=pf0[0]/(100.0 if itrim else 33.33)               #Medium to Low
                ol=np.mean(trace[idx1]%16384-gl*x[idx1])           #calculate offset
                pf1=np.array([gl,ol])
            else:
                pf1=np.array([0,0])                                #ore st to zero if not enough data points
            fits[iy,ix,0]=pf0
            fits[iy,ix,1]=pf1
            
            i=iy*mx+ix
            if i%256==255:  #display a subset of plots
                print '\b.',
                if display:
                    update_plot(handle,trace,xx,pf0,pf1)

    return fits,nsp

#--------------------

def find_file_for_timestamp(dirname, pattern, tstamp) :
    # list of file names in directory, dirname, containing pattern
    fnames = [name for name in os.listdir(dirname) if pattern in name]

    # list of int tstamps 
    # !!! here we assume specific name structure generated by file_name_prefix
    itstamps = [int(name.split('_',3)[2]) for name in fnames]

    # reverse-sort int timestamps in the list
    itstamps.sort(key=int,reverse=True)

    # find the nearest to requested timestamp
    for its in itstamps :
        if its <= int(tstamp) : break

    # find and return the full file name for selected timestamp
    ts = str(its)
    for name in fnames :
        if ts in name : 
             fname = '%s/%s' % (dirname, name)
             logger.debug('File %s\n  is selected for pattern %s and timestamp %s' % (fname,pattern,tstamp))
             return fname

    logger.warning('Directory %s\n DOES NOT CONTAIN the file for pattern %s and timestamp %s' % (dirname,pattern,tstamp))
    return None

#--------------------

def shape_from_config(det) :
    c = get_epix10ka_config_object(det.env, det.source)
    shape = (c.numberOfRows(), c.numberOfColumns())
    logger.debug('shape_from_config: %s' % str(shape))
    return shape

#--------------------

def print_config_info(c) :
    if c is not None :
         logger.debug('config: rows: %d, cols: %d, asics: %d' % (c.numberOfRows(), c.numberOfColumns(), c.numberOfAsics()))
         logger.debug('config: version: %d, asicMask: %d' % (c.version(), c.asicMask()))
         logger.debug('config: digitalCardId0: %d, 1: %d' % (c.carrierId0(), c.carrierId1()))
         logger.debug('config: digitalCardId0: %d, 1: %d' % (c.digitalCardId0(), c.digitalCardId1()))
         logger.debug('config: analogCardId0 : %d, 1: %d' % (c.analogCardId0(),  c.analogCardId1()))
         nasics = c.numberOfAsics()
         logger.debug('config: numberOfAsics        : %d' % nasics)
         logger.debug('config: asic trbits          : %s' % str([c.asics(i).trbit() for i in range(nasics)]))

#--------------------

def get_config_info(det) :
    env = det.env
    c = get_epix10ka_config_object(env, det.source)
    if c is None : return None, None

    print_config_info(c)
    
    panel_id = id_epix(c)
    panel_alias = alias_for_id(panel_id, fname='%s/aliases.txt'%CALIB_REPO_EPIX10KA)
    time_run = env_time(env)
    tstamp_run = str_tstamp(fmt='%Y%m%d%H%M%S', time_sec=time_run)
    tstamp_now = str_tstamp(fmt='%Y%m%d%H%M%S', time_sec=None)

    logger.debug('get_config_info parameters:'
                 + ('\n  epix10ka panel id   : %s' % panel_id)\
                 + ('\n  panel alias         : %s' % panel_alias)\
                 + ('\n  run time stamp      : %s' % tstamp_run)\
                 + ('\n  current time stamp  : %s' % tstamp_now))

    return tstamp_run, panel_id, panel_alias

#--------------------

def get_config_info_for_dataset_detname(dsname, detname) :
    ds = DataSource(dsname)
    det = Detector(detname)
    expnum = ds.env().expNum()
    shape = shape_from_config(det)
    for nevt,evt in enumerate(ds.events()):
        if det.raw(evt) is not None: 
            tstamp, panel_id, panel_alias = get_config_info(det)
            del ds
            del det
            return tstamp, panel_id, panel_alias, expnum, shape
    return None, None, None, expnum, shape

#--------------------

def dir_names(dirrepo, panel_id) :
    """Defines structure of subdirectories in calibration repository.
    """
    dir_panel  = '%s/%s' % (dirrepo, panel_id)
    dir_offset = '%s/offset'    % dir_panel
    dir_peds   = '%s/pedestals' % dir_panel
    dir_plots  = '%s/plots'     % dir_panel
    dir_work   = '%s/work'      % dir_panel
    dir_gain   = '%s/gain'      % dir_panel
    return dir_panel, dir_offset, dir_peds, dir_plots, dir_work, dir_gain
    
#--------------------

def file_name_prefix(panel_alias, tstamp, exp, irun) :
    return 'epix10ka_%s_%s_%s_r%04d' % (panel_alias, tstamp, exp, irun)

#--------------------

def file_name_npz(dir_work, fname_prefix, expnum, nspace) :
    return '%s/%s_e%04d_spacing%02d-df.npz' % (dir_work, fname_prefix, expnum, nspace)

#--------------------

def path_prefixes(fname_prefix, dir_offset, dir_peds, dir_plots) :
    prefix_offset= '%s/%s' % (dir_offset, fname_prefix)
    prefix_peds  = '%s/%s' % (dir_peds,  fname_prefix)
    prefix_plots = '%s/%s' % (dir_plots, fname_prefix)
    return prefix_offset, prefix_peds, prefix_plots

#--------------------

def offset_calibration(*args, **opts) :

    exp        = opts.get('exp', None)     
    detname    = opts.get('det', None)   
    irun       = opts.get('run', None)    
    nbs        = opts.get('nbs', 4600)    
    nspace     = opts.get('nspace', 7)    
    dirxtc     = opts.get('dirxtc', None) 
    dirrepo    = opts.get('dirrepo', CALIB_REPO_EPIX10KA)
    display    = opts.get('display', True)
    fmt_peds   = opts.get('fmt_peds', '%.3f')
    fmt_offset = opts.get('fmt_offset', '%.6f')

    logger.debug('In offset_calibration for exp:%s det:%s run:%d'%(exp, detname, irun))

    #dirxtc='/reg/d/psdm/mfx/mfxx32516/scratch/gabriel/pulser/xtc/combined'
    #path_in='/reg/d/psdm/mfx/mfxx32516/scratch/gabriel/pulser/res/'
    #path_out='/reg/d/psdm/mfx/mfxx32516/scratch/gabriel/pulser/res/out/'
    #for irun,nspace in runs:

    dsname = 'exp=%s:run=%d'%(exp,irun) if dirxtc is None else 'exp=%s:run=%d:dir=%s'%(exp, irun, dirxtc)
    logger.info('Calibration dataset %s' % dsname)
 
    tstamp, panel_id, panel_alias, expnum, shape = get_config_info_for_dataset_detname(dsname, detname)
    ny,nx = shape
 
    dir_panel, dir_offset, dir_peds, dir_plots, dir_work, dir_gain = dir_names(dirrepo, panel_id)
    fname_prefix = file_name_prefix(panel_alias, tstamp, exp, irun)
    prefix_offset, prefix_peds, prefix_plots = path_prefixes(fname_prefix, dir_offset, dir_peds, dir_plots)
    fname_work = file_name_npz(dir_work, fname_prefix, expnum, nspace)

    create_directory(dir_offset, mode=0777)
    create_directory(dir_peds,   mode=0777)
    create_directory(dir_plots,  mode=0777)
    create_directory(dir_work,   mode=0777)
    create_directory(dir_gain,   mode=0777)

    #--------------------
    # sys.exit('TEST EXIT')
    #--------------------

    try:
        npz=np.load(fname_work)
        logger.info('Loaded: %s' % fname_work)

        darks=npz['darks']
        fits_ml=npz['fits_ml']
        fits_hl=npz['fits_hl']

    except IOError:
        darks=np.zeros((ny,nx,7))
        fits_ml=np.zeros((ny,nx,2,2))
        fits_hl=np.zeros((ny,nx,2,2))
        nsp_ml=np.zeros((ny,nx),dtype=np.int16)
        nsp_hl=np.zeros((ny,nx),dtype=np.int16)

        #ds = DataSource('/reg/d/psdm/mfx/mfxx32516/scratch/gabriel/pulser/xtc/pslab03/e0-r1013-s00-c00.xtc')
        ds = DataSource(dsname)
        det = Detector(detname)

        for nstep, step in enumerate(ds.steps()):
            
            #First 5 Calib Cycles correspond to darks:
            if nstep<=4:
                print 'DARK %d' % nstep,
                #dark
                block=np.zeros((nbs,ny,nx),dtype=np.int16)
                for nevt,evt in enumerate(step.events()):
                    raw = det.raw(evt)
                    if raw is None:
                        print 'none'
                        continue
                    if nevt>=nbs:
                        break
                    else:
                        #block=insert_subframe(block,raw,nevt,nspace,nevt-5)
                        block[nevt]=raw
                        if nevt%128==0:
                            print '\b.',
                darks[:,:,nstep]=block.mean(0)

            #Next nspace**2 Calib Cycles correspond to pulsing in Auto Medium-to-Low    
            elif nstep<5+nspace**2:
                print ' AML %2d/%2d'%(nstep-5+1,nspace**2),
                #data
                block=np.zeros((nbs,ny,nx),dtype=np.int16)
                for nevt,evt in enumerate(step.events()):   #read all frames
                    raw = det.raw(evt)
                    if raw is None:
                        print 'none'
                        continue
                    if nevt>=nbs:
                        break
                    else:
                        #block=insert_subframe(block,raw,nevt,nspace,nevt-5)
                        block[nevt]=raw
                        if nevt%200==0:
                            print '\b.',
        
                istep=nstep-5
                jy=istep//nspace
                jx=istep%nspace                    
                block=block[:,jy:ny:nspace,jx:nx:nspace]   #select only pulsed pixels
                fits0,nsp0=fit(block,0,display=display)    #fit offset, gain
                fits_ml[jy:ny:nspace,jx:nx:nspace]=fits0   #collect results
                nsp_ml[jy:ny:nspace,jx:nx:nspace]=nsp0
                #print 'NEVT='+str(nevt)
                darks[:,:,6]=darks[:,:,4]-fits_ml[:,:,1,1]
                
            #Next nspace**2 Calib Cycles correspond to pulsing in Auto High-to-Low    
            elif nstep<5+2*nspace**2:
                print ' AHL %2d/%2d'%(nstep-5-nspace**2+1,nspace**2),
                block=np.zeros((nbs,ny,nx),dtype=np.int16)
                for nevt,evt in enumerate(step.events()):   #read all frames
                    raw = det.raw(evt)
                    if raw is None:
                        print 'none'
                        continue
                    if nevt>=nbs:
                        break
                    else:
                        #block=insert_subframe(block,raw,nevt,nspace,nevt-5)
                        block[nevt]=raw
                        if nevt%200==0:
                            print '\b.',
        
                istep=nstep-5-nspace**2
                jy=istep//nspace
                jx=istep%nspace                    
                block=block[:,jy:ny:nspace,jx:nx:nspace]   #select only pulsed pixels
                fits0,nsp0=fit(block,1,display=display)    #fit offset, gain
                fits_hl[jy:ny:nspace,jx:nx:nspace]=fits0   #collect results
                nsp_hl[jy:ny:nspace,jx:nx:nspace]=nsp0
                #print 'NEVT='+str(nevt)
                darks[:,:,5]=darks[:,:,3]-fits_hl[:,:,1,1]
                
                #test=update_test(test,block,nspace,nstep-5)
            print
            if nstep>=5+2*nspace**2:
                break
        #Save diagnostics data, can be commented out:
        #save fitting results
        np.savez_compressed(fname_work, darks=darks, fits_hl=fits_hl, fits_ml=fits_ml, nsp_hl=nsp_hl, nsp_ml=nsp_ml) 
        logger.info('Saved:  %s' % fname_work)

    #Calculate and save offsets:
    offset_ahl=fits_hl[:,:,1,1]
    offset_aml=fits_ml[:,:,1,1]
    fname_offset_AHL = '%s_offset_AHL.dat' % prefix_offset
    fname_offset_AML = '%s_offset_AML.dat' % prefix_offset
    np.savetxt(fname_offset_AHL, offset_ahl, fmt=fmt_offset)
    np.savetxt(fname_offset_AML, offset_aml, fmt=fmt_offset)
    #np.savetxt(path_out+'offset/offset_AHL_R%04d.dat'%irun,offset_ahl)
    #np.savetxt(path_out+'offset/offset_AML_R%04d.dat'%irun,offset_aml)
    logger.info('Saved:  %s' % fname_offset_AHL)
    logger.info('Saved:  %s' % fname_offset_AML)

    #Save darks in separate files:
    for i in range(5):  #looping through darks measured in Jack's order
        fnameped = '%s_pedestals_%s.dat' % (prefix_peds, GAIN_MODES[i])
        np.savetxt(fnameped, darks[:,:,i], fmt=fmt_peds)
        logger.info('Saved:  %s' % fnameped)
        #fnameped='pedestals/pedestal_%s_R%04d.dat'%(GAIN_MODES[i],irun)
        #np.savetxt(path_out+fnameped, darks[:,:,i])
        if i==3:    #if AHL_H, we can calculate AHL_L
            fnameped = '%s_pedestals_AHL-L.dat' % prefix_peds
            np.savetxt(fnameped, darks[:,:,i]-offset_ahl, fmt=fmt_peds)
            logger.info('Saved:  %s' % fnameped)
            #fnameped='pedestals/pedestal_AHL_L_R%04d.dat'%irun    
            #np.savetxt(path_out+fnameped, darks[:,:,i]-offset_ahl)
        elif i==4:    #if AML_M, we can calculate AML_L
            fnameped = '%s_pedestals_AML-L.dat' % prefix_peds
            np.savetxt(fnameped, darks[:,:,i]-offset_aml, fmt=fmt_peds)
            logger.info('Saved:  %s' % fnameped)
            #fnameped='pedestals/pedestal_AML_L_R%04d.dat'%irun    
            #np.savetxt(path_out+fnameped, darks[:,:,i]-offset_aml)
            
    #Save all darks in one file in Mikhail's format
    darks_m=np.zeros((7,1,352,384))
    lut=[2,1,0,6,4,5,3]    #look-up table from Jack scripts' format to Mikhail's format
    for i in range(7):
        darks_m[lut[i],0]=darks[:,:,i]
    np.savetxt('%s_pedestals.dat' % prefix_peds, darks[:,:,i]-offset_aml, fmt=fmt_peds)
    #fnameped='pedestals/pedestals_R%04d.dat'%irun
    #np.savetxt(path_out+fnameped, darks[:,:,i]-offset_aml)
        
    if display:
        plt.close("all")
        fnameout='%s_plot_AML.pdf' % prefix_plots
        #fnameout='pdf/pdf_AML_R%04d.pdf'%irun
        gm='AML'; titles=['M Gain','M Pedestal', 'L Gain', 'M-L Offset']
        plt.figure(1,facecolor='w',figsize=(11,8.5),dpi=72.27);plt.clf()
        plt.suptitle(gm)
        for i in range(4):
            plt.subplot(2,2,i+1)
            test=fits_ml[:,:,i//2,i%2]; testm=np.median(test); tests=3*np.std(test)
            plt.imshow(test,interpolation='nearest',cmap='Spectral',vmin=testm-tests,vmax=testm+tests)
            plt.colorbar()
            plt.title(gm+': '+titles[i])
        plt.pause(0.1)
        plt.savefig(fnameout)
        logger.info('Saved:  %s' % fnameout)

        fnameout='%s_plot_AHL.pdf' % prefix_plots
        #fnameout='pdf/pdf_AHL_R%04d.pdf'%irun    
        gm='AHL'; titles=['H Gain','H Pedestal', 'L Gain', 'H-L Offset']
        plt.figure(2,facecolor='w',figsize=(11,8.5),dpi=72.27);plt.clf()
        for i in range(4):
            plt.subplot(2,2,i+1)
            test=fits_hl[:,:,i//2,i%2]; testm=np.median(test); tests=3*np.std(test)
            plt.imshow(test,interpolation='nearest',cmap='Spectral',vmin=testm-tests,vmax=testm+tests)
            plt.colorbar()
            plt.title(gm +': '+titles[i])
        plt.pause(0.1)
        plt.savefig(fnameout)
        logger.info('Saved:  %s' % fnameout)
        plt.pause(5)

    logger.info('DONE')

#--------------------

def pedestals_calibration(*args, **opts) :

    exp        = opts.get('exp', None)
    detname    = opts.get('det', None)
    irun       = opts.get('run', None)
    nbs        = opts.get('nbs', 1024)
    nspace     = opts.get('nspace', 7)    
    dirxtc     = opts.get('dirxtc', None)
    dirrepo    = opts.get('dirrepo', CALIB_REPO_EPIX10KA)
    fmt_peds   = opts.get('fmt_peds', '%.3f')
    mode       = opts.get('mode', 'AML-M')    

    logger.debug('In pedestals_calibration for exp:%s det:%s run:%d'%(exp, detname, irun))

    #dirxtc='/reg/d/psdm/mfx/mfxx32516/scratch/gabriel/pulser/xtc/combined'
    #path_in='/reg/d/psdm/mfx/mfxx32516/scratch/gabriel/pulser/res/'
    #path_out='/reg/d/psdm/mfx/mfxx32516/scratch/gabriel/pulser/res/out/'
    #for irun,nspace in runs:

    dsname = 'exp=%s:run=%d'%(exp,irun) if dirxtc is None else 'exp=%s:run=%d:dir=%s'%(exp, irun, dirxtc)
    logger.info('Calibration dataset %s' % dsname)
 
    tstamp, panel_id, panel_alias, expnum, shape = get_config_info_for_dataset_detname(dsname, detname)
    ny,nx = shape

    dir_panel, dir_offset, dir_peds, dir_plots, dir_work, dir_gain = dir_names(dirrepo, panel_id)
    fname_prefix = file_name_prefix(panel_alias, tstamp, exp, irun)
    prefix_offset, prefix_peds, prefix_plots = path_prefixes(fname_prefix, dir_offset, dir_peds, dir_plots)
    fname_work   = file_name_npz(dir_work, fname_prefix, expnum, nspace)

    logger.info('Directories under %s\n  SHOULD ALREADY EXIST after offset_calibration' % dir_panel)
    assert os.path.exists(fname_work), 'File "%s" DOES NOT EXIST' % fname_work
    assert os.path.exists(dir_offset), 'Directory "%s" DOES NOT EXIST' % dir_offset
    assert os.path.exists(dir_peds),   'Directory "%s" DOES NOT EXIST' % dir_peds
    assert os.path.exists(dir_work),   'Directory "%s" DOES NOT EXIST' % dir_work

    #--------------------
    #sys.exit('TEST EXIT')
    #--------------------

    #paths, file names:
    #path_xtc='/reg/d/psdm/mfx/mfxx32516/scratch/gabriel/pulser/xtc/combined/'           #location to read dark data (only necessary for script development)
    #path_offset='/reg/d/psdm/mfx/mfxx32516/scratch/gabriel/pulser/res/out/offset/'      #location to read offset files
    #path_pedestal='/reg/d/psdm/mfx/mfxx32516/scratch/gabriel/pulser/res/out/pedestals/' #location to save pedestals
    #fname_offset_AML='offset_AML_R1022.dat'     #current AML offset file
    #fname_offset_AHL='offset_AHL_R1022.dat'     #current AHL offset file
    ####for pedestal file names, see the 3 'np.savetxt()' commands below

    mode=mode.upper()

    if not (mode in GAIN_MODES_IN) :
        logger.warning('UNRECOGNIZED GAIN MODE: %s, DARKS NOT UPDATED.'%mode)
        return

    #read input xtc file and calculate pedestal
    #(currently misusing the first calib cycle of an existing file)

    ds = DataSource(dsname)
    det = Detector(detname)

    msg='READING %s FRAMES '%(mode)
    for nstep, step in enumerate(ds.steps()): #(loop through calyb cycles, using only the first):
        block=np.zeros((nbs,ny,nx),dtype=np.int16)
        ievt=0;
        for nevt,evt in enumerate(step.events()):
            raw = det.raw(evt)
            if raw is None:     #skip empty frames
                msg+='none'
                continue
            if ievt>=nbs:       #stop after collecting sufficient frames
                break;
            else:
                #block=insert_subframe(block,raw,nevt,nspace,nevt-5);
                block[ievt]=raw;
                ievt+=1;
                if nevt%200==0: # simple progress bar
                    msg+='\b.'
        if nstep>=0:    #only process the first CalibCycle (stop after 0)
            break

    logger.info(msg)

    dark=block.mean(0)  #Calculate mean 
    
    #save dark in proper place
    #fnameout=path_pedestal+'pedestal_%s_R%04d.dat'%(mode,irun);
    #np.savetxt(fnameout,dark);
    #print 'SAVED %s PEDESTALS.'%mode,
    fnameped = '%s_pedestals_%s.dat' % (prefix_peds, mode)
    np.savetxt(fnameped, dark, fmt=fmt_peds)
    logger.info('Saved:  %s' % fnameped)

    #if this is an auto gain ranging mode, also calculate the corresponding _L pedestal:
    if mode=='AML-M':
        fname_offset_AML = find_file_for_timestamp(dir_offset, 'offset_AML', tstamp)
        offset=np.loadtxt(fname_offset_AML);
        logger.info('Loaded: %s' % fname_offset_AML) 
        fnameped = '%s_pedestals_AML-L.dat' % prefix_peds
        np.savetxt(fnameped, dark-offset, fmt=fmt_peds)
        logger.info('Saved:  %s' % fnameped) 

        #fnameout=path_pedestal+'pedestal_%s_R%04d.dat'%('AML_L',irun);
        #np.savetxt(fnameout,dark-offset);
        #print 'SAVED AML_L PEDESTALS.',

    elif mode=='AHL-H':
        fname_offset_AHL = find_file_for_timestamp(dir_offset, 'offset_AHL', tstamp)
        offset=np.loadtxt(fname_offset_AHL);
        logger.info('Loaded: %s' % fname_offset_AHL) 
        fnameped = '%s_pedestals_AHL-L.dat' % prefix_peds
        np.savetxt(fnameped, dark-offset, fmt=fmt_peds)
        logger.info('Saved:  %s' % fnameped)

        #fnameout=path_pedestal+'pedestal_%s_R%04d.dat'%('AHL_L',irun);
        #np.savetxt(fnameout,dark-offset);
        #print 'SAVED AHL_L PEDESTALS.',

    logger.info('DONE')

#--------------------

if __name__ == "__main__" :
    def test_offset_calibration(tname) :
        offset_calibration(exp     = 'mfxx32516',\
                           det     = 'NoDetector.0:Epix10ka.3',\
                           run     = 1021,\
                           nbs     = 4600,\
                           nspace  = 2,\
                           dirxtc  = '/reg/d/psdm/mfx/mfxx32516/scratch/gabriel/pulser/xtc/combined',\
                           dirrepo = './work',\
                           display = True)

#--------------------

if __name__ == "__main__" :
    def test_pedestals_calibration(tname) :
        pedestals_calibration(exp  = 'mfxx32516',\
                           det     = 'NoDetector.0:Epix10ka.3',\
                           run     = 1021,\
                           nbs     = 1024,\
                           nspace  = 2,\
                           mode    = 'AML-M',\
                           dirxtc  = '/reg/d/psdm/mfx/mfxx32516/scratch/gabriel/pulser/xtc/combined',\
                           dirrepo = './work')

#--------------------

#runs=[#[1020,4],
#      [1021,2],
#      [1022,6],
#      [1023,4],
#      [1024,2],
#      [1025,6],
#      #[1026,],  #incomplete?   #-20C
#      [1027,2],
#      [1028,6],
#      [1029,4]]

#--------------------

if __name__ == "__main__" :
    print(80*'_')
    logging.basicConfig(format='%(levelname)s: %(message)s', level=logging.DEBUG)
    tname = sys.argv[1] if len(sys.argv)>1 else '1'
    if tname == '1' : test_offset_calibration(tname)
    if tname == '2' : test_pedestals_calibration(tname)
    else : sys.exit ('Not recognized test name: "%s"' % tname)
    sys.exit('End of %s' % sys.argv[0])

#--------------------
